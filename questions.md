Q: What are the main core functions in the codebase versus more specialized ones for understanding structure?
A: Core: `kernel/create.m` (spin_system assembly, tolerances), `kernel/basis.m` (state space setup), `kernel/hamiltonian.m` (Hamiltonian/Liouvillian assembly), `kernel/relaxation.m` (relaxation/kinetics terms), `kernel/operator.m` (basis operators), `kernel/propagator.m` (matrix exponential), `kernel/step.m` and `kernel/evolution.m` (time propagation), `kernel/steady.m`/`kernel/thermalize.m` (steady/thermal states), plus common manipulations like `kernel/reduce.m`, `kernel/correlation.m`, `kernel/coherence.m`, `kernel/orientation.m`, `kernel/carrier.m`, `kernel/frqoffset.m`, `kernel/rotframe.m`, `kernel/spin.m`, and core spin-dynamics actions (`kernel/spinlock.m`, `kernel/decouple.m`, `kernel/homospoil.m`, `kernel/average.m`). Specialized/support: folders `kernel/pulses`, `kernel/optimcon`, `kernel/kinetics`, `kernel/contexts`, `kernel/conventions`, `kernel/grids`, `kernel/house_style`, `kernel/cache`, `kernel/overloads`, `kernel/includes`, `kernel/undocs`, `kernel/states`; files like `kernel/krylov.m`, `kernel/trajan.m`, `kernel/trajsimil.m`, `kernel/residual.m`, `kernel/average.m`, `kernel/coherence.m`, `kernel/decouple.m`, `kernel/spinlock.m` can be treated as feature-specific or alternative paths.

Q: What is the physical difference between `control.pwr_levels` and `control.amplitudes` in Spinach optimal control?
A: `control.pwr_levels` is the list of possible RF strengths (nutation frequencies) you want the pulse to tolerate—an ensemble of B1 calibration/inhomogeneity values. For a phase-only GRAPE, the optimizer must work for every value in this list, so the same pulse is optimized across all these RF amplitudes. `control.amplitudes` is the time-domain envelope of the pulse for a given RF strength—one scalar per time step that shapes how much of the selected `pwr_level` is applied at that time. Physically, for a given ensemble member with RF strength `pwr_levels(j)`, the instantaneous B1 amplitude is `B1(t)=pwr_levels(j)*amplitudes(t)`, and the Cartesian fields are `B1_x(t)=B1(t)*cos(phi(t))`, `B1_y(t)=B1(t)*sin(phi(t))`. Using `amplitudes=ones(1,N)` gives a constant-amplitude pulse over N time steps; using a shaped vector gives a fixed amplitude shape that is scaled up or down for each `pwr_levels` value.
